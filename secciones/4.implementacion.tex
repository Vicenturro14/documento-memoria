\chapter{Implementación}
En este capítulo se describirá la implementación realizada durante la memoria.
Esta se separa puede separar en tres partes, la primera es la implementación relacionada
con los estudiantes del ramo Trabajo de Título, también llamado F. La segunda parte
corresponde a la asignación de comisiones examinadoras. La tercera parte corresponde a la
exportación de comisiones examinadoras.

\section{Estudiantes de Trabajo de Título}

\subsection{Módulo de Trabajo de Título}
Para implementar funcionalidades relacionadas con el ramo Trabajo de Título y
separarlas de las funcionalidades del ramo Introducción al Trabajo de Título, se creó el
módulo de Trabajo de Título. Esta separación también evita que la barra de navegación se
llene de pestañas. Para acceder al módulo, se creó un selector en la barra de navegación,
que se ubica en la parte superior de la página, como se puede ver en la figura
\ref{fig:implementacion_selector}. Como por el momento las únicas funcionalidades asociadas
al módulo de Trabajo de Título son ver los estudiantes de Trabajo de Título y la asignación
de comisiones examinadoras, y ambas requieren permisos de coordinación de titulación, el
selector solo es visible para coordinadores, que está manejado por la variable booleana
\verb|show_module_selector|, como se muestra en la línea 11 del código \ref{lst:barra_navegacion}.
Al seleccionar el módulo Introducción al Trabajo de Título, el usuario es redirigido a la
raíz de la aplicación. Mientras que al seleccionar el módulo Trabajo de Título, el usuario
es redirigido a la vista principal de Trabajo de Título, que es el listado de estudiantes de
Trabajo de Título.

Como anteriormente todo el sistema estaba dedicado al ramo Introducción al Trabajo de
Título, el título de la barra de navegación era el nombre del módulo. Por lo tanto, se
creó el módulo Trabajo de Título para poder separarlo del módulo de Introducción al
Trabajo de Título. Además, el título de la barra de navegación se cambió a un título
configurable mediante la variable \verb|titulo| y si esta variable no se especifica, se
muestra el nombre del módulo. Se decidió dejar este caso, ya que el header es el mismo para
todos los módulos y el resto de módulos no requieren un título personalizado.


\begin{figure}[ht]
  \begin{subfigure}[b]{0.47\textwidth}
    \centering
    \includegraphics[width=\linewidth]{imagenes/implementaciones/selector_seccion_cerrado.png}
    \caption{Captura de pantalla del selector cerrado en la barra de navegación en el módulo de Introducción al Trabajo de Título.}
    \label{fig:implementacion_selector_cerrado}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.47\textwidth}
    \centering
    \includegraphics[width=\linewidth]{imagenes/implementaciones/selector_seccion_abierto.png}
    \caption{Captura de pantalla del selector abierto en la barra de navegación en el módulo de Introducción al Trabajo de Título.}
    \label{fig:implementacion_selector_abierto}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.47\textwidth}
    \centering
    \includegraphics[width=\linewidth]{imagenes/implementaciones/selector_seccion_trabajo_titulo.png}
    \caption{Captura de pantalla del selector cerrado en la barra de navegación en el módulo de Trabajo de Título.}
    \label{fig:implementacion_selector_trabajo_titulo}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.47\textwidth}
    \centering
    \includegraphics[width=\linewidth]{imagenes/implementaciones/selector_seccion_trabajo_titulo_abierto.png}
    \caption{Captura de pantalla del selector abierto en la barra de navegación en el módulo de Trabajo de Título.}
    \label{fig:implementacion_selector_trabajo_titulo_abierto}
  \end{subfigure}
  \caption{Capturas de pantalla del selector en la barra de navegación.}
  \label{fig:implementacion_selector}
\end{figure}

\begin{lstlisting}[language=HTML, caption={Código de la parte central de la barra de navegación}, label={lst:barra_navegacion}]
    <div class="header">
      <a href="{% url 'servicios:index' %}" class="logo"><span class="dcc">dc<span>c</span></span></a>
      <div class="d-flex flex-column flex-grow-1 align-items-center pt-2">
        <h1 class="modulo mb-0">
          {% if titulo %}
            {{ titulo }}
          {% else %}
            {{ modulo.nombre }}
          {% endif %}
        </h1>
        {% if show_module_selector %}
          <div class="dropdown-center">
            <button class="btn btn-dark dropdown-toggle" type="button" data-bs-toggle="dropdown">
              {{ modulo.nombre }}
            </button>
            <ul class="dropdown-menu">
              {% for mod in modules %}
                <li>
                  <a class="dropdown-item {% if mod.nombre == modulo.nombre %} disabled {% endif %}"
                     href="{% if mod.nombre == modulo.nombre %} # {% else %} {{ mod.url }} {% endif %}">
                    {{ mod.nombre }}
                  </a>
                </li>
              {% endfor %}
            </ul>
          </div>
        {% endif %}
      </div>
    </div>
\end{lstlisting}

\subsection{Listado de estudiantes de Trabajo de Título}

La asignación de comisiones examinadoras a los estudiantes de Trabajo de Título, requiere
tener un registro de los estudiantes que están cursando Trabajo de Título junto con sus
respectivos temas de memoria. Por lo tanto, dentro del módulo de Trabajo de Título se
creó una vista que lista los estudiantes que están cursando Trabajo de Título, que se
puede ver en la figura \ref{fig:listado_estudiantes_f}.

En esta vista se muestra una tabla que por cada estudiante muestra su nombre, el título
de su memoria, su guía, su coguía si tiene y un botón que redirige a su ficha. Sobre la
tabla al costado derecho se encuentra una barra de búsqueda que permite buscar por nombre
de estudiante, título de memoria, nombre de guía y nombre de coguía. Sobre esta barra, se
encuentra un filtro que permite elegir el semestre académico de los estudiantes que se
mostrarán en la tabla. Por defecto se mostrarán los estudiantes del semestre académico
activo. Por último, al costado derecho de este filtro está el botón de
\textit{Sincronizar}, que permite actualizar la tabla con los estudiantes.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{imagenes/implementaciones/listado_estudiantes_f.png}
  \caption{Captura de pantalla de la vista del listado de estudiantes de Trabajo de Título.}
  \label{fig:listado_estudiantes_f}
\end{figure}

Para la actualización del registro se tomó en cuenta que los estudiantes deben estar
cursando alguna sección de los ramos de Trabajo de Título, CC6909 y CC6919, por lo
tanto se puede obtener los nombres de los estudiantes desde la API de UCampus. Además,
los estudiantes deben haber aprobado Introducción al Trabajo de Título, por lo que se
asume que los temas de los estudiantes ya se encuentran registrados en el sistema de
titulación y que también hay una instancia del modelo Propuesta para cada estudiante
asociada a su tema y con estado aprobado, haciendo posible asociar a los estudiantes que
cursan Trabajo de Título con sus temas.

Dada la asunción anterior, para actualizar el registro de estudiantes de Trabajo de
Título dentro del sistema de titulación se creó un comando de administración
\verb|upd_estudiantes_f|, que es llamado por el botón \textit{Sincronizar}.
Este obtiene desde la API de UCampus todas las secciones de
los ramos de Trabajo de Título y para después obtener los integrantes de cada sección.
Luego, por cada integrante se busca la instancia del modelo Propuesta con estado
aprobado más reciente asociada al estudiante, pues puede haber varias instancias
asociadas al mismo estudiante. Si se encuentra una instancia, se obtiene el tema asociado
y se crea una instancia del modelo MemoriaEnF con el estudiante y su tema. En caso
contrario, se registra en el log que para ese estudiante no se encontró una instancia,
se agrega al estudiante a la lista de estudiantes sin una instancia y se continua con el
siguiente integrante. Al finalizar el proceso se muestra un mensaje indicando cuántos
estudiantes no tuvieron una instancia, como se ve en la figura \ref{fig:estudiante_sin_tema}.
Una vez que termina la ejecución del comando, se recarga la página y se muestra la lista
actualizada de estudiantes de Trabajo de Título.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.6\linewidth]{imagenes/implementaciones/estudiante_sin_tema.png}
  \caption{Captura de pantalla de la notificación de que un estudiante no tiene un tema registrado.}
  \label{fig:estudiante_sin_tema}
\end{figure}

Como se mencionó en la descripción del comando, puede suceder que haya estudiantes que no
tengan una instancia de Tema y Propuesta con estado Aprobado. Esto sucede por lo que la
asunción puede no ser cierta para estudiantes que hayan solicitado la vía rápida, pues
actualmente ese proceso no se encuentra implementado en el sistema de titulación y se
realiza directamente con la coordinación de titulación. El caso de la vía rápida no
se manejará en esta memoria, ya que al momento del desarrollo de este trabajo de título,
había otro tema de memoría sobre la incorporación de un módulo de vía rápida. Mientras
que tanto, basta con crear una instancia de Tema y Propuesta con estado Aprobado para
cada estudiante de vía rápida mediante el administrador de Django o por consola para que
puedan ser incluidos en la lista de estudiantes de Trabajo de Título.

\subsection{Vista de \textit{Mis Memoristas} para académicos}
Habiendo incorporado a los estudiantes de Trabajo de Título al sistema de titulación,
se extendió la vista de \textit{Mis Memoristas} que es visible para académicos, para que
pudieran ver una lista de sus memoristas en Trabajo de Título. Para ello se agregó un
selector de ramo de titulación que permite elegir entre Introducción al Trabajo de Título
y Trabajo de Título. Este se encuentra bajo la barra de navegación de la vista, a la
izquierda del filtro de periodo académico. En la figura
\ref{subfig:implementacion_mis_memoristas_e} se muestra el selector en la vista con memoristas
de Introducción al Trabajo de Título, mientras que en la figura
\ref{subfig:implementacion_mis_memoristas_f} se muestra el selector en la vista con memoristas
de Trabajo de Título.

Al seleccionar Trabajo de Título, se muestra la lista de los estudiantes de Trabajo de Título
que son memoristas del usuario. Por cada estudiante se muestra su nombre, su título de memoria,
su guía, su coguía si tiene y un botón a la ficha del estudiante. El resto de la vista se mantiene
igual que la vista para Introducción al Trabajo de Título.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics[width=\linewidth]{imagenes/implementaciones/mis_memoristas_e.png}
    \caption{Captura de pantalla de la vista de \textit{Mis Memoristas} para Introducción al Trabajo de Título.}
    \label{subfig:implementacion_mis_memoristas_e}
  \end{subfigure}
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics[width=\linewidth]{imagenes/implementaciones/mis_memoristas_f.png}
    \caption{Captura de pantalla de la vista de \textit{Mis Memoristas} para Trabajo de Título.}
    \label{subfig:implementacion_mis_memoristas_f}
  \end{subfigure}
  \caption{Vista de \textit{Mis Memoristas} para académicos con selector de ramo de titulación.}
  \label{fig:implementacion_mis_memoristas}
\end{figure}

% \begin{lstlisting}[language=HTML]
% <div class="form-responsive-container">
%   <select class="filtro form-select"
%           onchange="window.location = this.options[this.selectedIndex].value;">
%     {% for m in modules %}
%       <option value="{{ m.mis_memoristas_url }}" {% if m.nombre == modulo.nombre %}selected{% endif %}>{{ m.nombre }}</option>
%     {% endfor %}
%   </select>
% </div>
% \end{lstlisting}



\section{Asignación de Comisiones}
En esta sección se describe la implementación de funcionalidades relacionadas con la
asignación de comisiones examinadoras. Primero se mencionarán las funcionalidades que se
implementaron para la evaluación de la herramienta, y luego se describirán las
modificaciones que se surgieron a partir de la retroalimentación recibida en la
evaluación.

El sistema piloto desarrollado por el equipo de ingeniería de software II ya contaba con
la funcionalidad de asignación de comisiones examinadoras, tal como se menciona en la
sección \ref{sec:sa:asignacion}. Sin embargo, esta funcionaba con el modelo
AlumnoCursandoMemoria, por lo que se adaptó para que funcione con el nuevo modelo
MemoriaEnF, manteniendo la tabla de comisiones examinadoras que muestra una lista de
memorias con sus respectivos estudiantes, temas, guías, coguías e integrantes de la comisión.
Al final de cada fila se encuentra un botón que permite asignar evaluadores a la comisión. La figura
\ref{fig:comisiones_asignacion} muestra la lista de memorias con sus comisiones examinadoras .

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\linewidth]{imagenes/implementaciones/lista_comisiones.png}
  \caption{Captura de pantalla de la lista de memorias con sus comisiones examinadoras.}
  \label{fig:comisiones_asignacion}
\end{figure}

\subsection{Filtro de Comisiones Examinadoras}
Una vez adaptada la implementación al nuevo modelo, se le agregaron funcionalidades.
En primer lugar, se agregó un filtro de comisiones examinadoras en la interfaz
principal del módulo de comisiones examinadoras. Este filtro permite configurar los
trabajos de título que se muestran dependiendo de la cantidad de evaluadores asignados a
la comisión examinadora. Si se selecciona ``Todas las memorias'', se muestran todos los
trabajos de título, si se selecciona ``Con comisión completa'', se muestran solo aquellas
que tengan dos o más evaluadores asignados, y si se selecciona ``Con comisión
incompleta'', se muestran aquellas que tengan un evaluador o ninguno. En la figura
\ref{fig:comisiones_filtradas} se muestra el filtro configurado para mostrar solo las
memorias con comisión completa. Internamente, el filtro refresca la página y agrega un
query parameter a la URL que indica el filtro seleccionado. Desde el backend se filtran
las comisiones según el query parameter, como se muestra en el código \ref{lst:filtro_comisiones}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\linewidth]{imagenes/implementaciones/comisiones_filtradas.png}
  \caption{Captura de pantalla de la lista de comisiones examinadoras filtrada por comisiones completas.}
  \label{fig:comisiones_filtradas}
\end{figure}

\begin{lstlisting}[language=Python, caption={Filtrado de comisiones examinadoras.}, label={lst:filtro_comisiones}]
  memorias = MemoriaEnF.objects.filter(periodo=periodo).select_related(
    "tema__guia__persona",
    "tema__coguia__persona",
    "estudiante__persona",
  ).prefetch_related(
    "comision__evaluadores"
  ).annotate(
    Count("comision__evaluadores")
  )
  # Filtrado por comision completa, incompleta o todas
  if comision_filter == "completas":
    memorias_filtradas = memorias.filter(comision__evaluadores__count__gte=2)
  elif comision_filter == "incompletas":
    memorias_filtradas = memorias.filter(comision__evaluadores__count__lt=2)
  else:
    memorias_filtradas = memorias

  # Ordenar: primero con tema (True > False)
  memorias_filtradas = sorted(
    memorias_filtradas,
    key= lambda memoria: (
      memoria.tema is None, # False (tienen tema) va antes
      memoria.estudiante.persona.apellido1.lower() if memoria.estudiante.persona.apellido1 else "",
      memoria.estudiante.persona.nombre1.lower() if memoria.estudiante.persona.nombre1 else "",
    )
  )
  context["memorias"] = memorias_filtradas
\end{lstlisting}


\subsection{Gráfico de Carga de Evaluadores}
El mayor cambio visual en la interfaz del módulo de comisiones proviene de la
incorporación del gráfico que muestra la carga de evaluadores. Este se ubica sobre la
lista de comisiones examinadoras, como se muestra en la figura
\ref{fig:grafico_carga_evaluadores}. Cada columna representa la carga de un evaluador,
que está dividida entre la carga proveniente de las memorias guíadas o coguiadas y la carga
proveniente de las comisiones examinadoras que integra. Es importante destacar que integrar
una comisión examinadora equivale a un punto de carga, mientras que guiar o coguir una memoria
equivale a dos puntos de carga. Esta ponderación fue recomendada por la coordinadora de titulación.
Al posicionar el cursor sobre una columna, se muestra un tooltip que indica la cantidad de comisiones
y la cantidad de memorias.

El gráfico está ordenado de mayor a menor función de la carga total de cada evaluador, es
decir, por la siguiente fórmula: $carga\_total = 2*memorias\_guiadas + comisiones\_integradas$.
Este orden ayuda a que sea fácil identificar a los evaluadores con mayor y menor carga.
Además, el gráfico se actualiza cada vez que se asignan integrantes a una comisión examinadora y
no se ve afectado por el filtro de comisiones. Por último, el gráfico puede ocultarse y mostrarse
mediante un botón que se encuentra bajo la barra de navegación, entre el filtro de comisiones
y el botón de sincronización.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{imagenes/implementaciones/grafico_evaluadores.png}
  \caption{Captura de pantalla del gráfico de carga de evaluadores.}
  \label{fig:grafico_carga_evaluadores}
\end{figure}


\subsection{Modal de asignación de comisiones}
Al presionar el botón para asignar integrantes a una comisión examinadora, se abre un modal
para realizar la asignación. Este modal también se encontraba en la versión piloto del sistema,
pero al igual que la tabla de comisiones examinadoras, se adaptó para que use el modelo
MemoriaEnF en vez de AlumnoCursandoMemoria. Además, en el modal se agregó el nombre del estudiante.
En la figura \ref{fig:modal_asignacion_comisiones} se muestra el modal con los cambios realizados.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\linewidth]{imagenes/implementaciones/modal.png}
  \caption{Captura de pantalla del modal de asignación de comisiones.}
  \label{fig:modal_asignacion_comisiones}
\end{figure}

Un cambio importante es que se agregaron validaciones en la asignación de comisiones. En
particular, se valida que al guardar una comisión examinadora, esta tenga al menos dos
integrantes, que ninguno de los integrantes sea guía o coguía de la memoria y que al
menos uno de los integrantes tenga jerarquía de Académico de Jornada Completa (AJC) o
Académico de Jornada Parcial (AJP). Si se intenta guardar una comisión examinadora que
no cumpla con estas validaciones, se muestra un mensaje de error. En la figura
En el código \ref{lst:validacion_comision} se muestra la implementación de las
validaciones, mientras que en la figura \ref{fig:validaciones_comision} se muestran los
mensajes de error por validación.

\begin{lstlisting}[language=Python, caption={Validación de comisión examinadora.}, label={lst:validacion_comision}, escapechar=|]
# Validaci|\'o|n de comisi|\'o|n
if len(evaluadores) < 2:
    return JsonResponse({"success": False, "message": "Debe agregar al menos dos evaluadores."})

rut_guia = comision.get_guia.persona.rut if comision.memoria.tema.guia else None
rut_coguia = comision.get_coguia.persona.rut if comision.memoria.tema.coguia else None

has_non_pex = False
for evaluador in evaluadores:
  if evaluador.persona.rut in (rut_guia, rut_coguia):
    return JsonResponse({"success": False, "message": "No puede seleccionar a los gu|\'i|as como evaluadores."})

  if evaluador.tipo.nombre != "PEX":
    has_non_pex = True

if not has_non_pex:
  return JsonResponse({"success": False, "message": "Debe elegir al menos un integrante AJC o AJP."})

comision.evaluadores.add(*evaluadores)
\end{lstlisting}

\newpage

\begin{figure}[ht!]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{imagenes/implementaciones/validacion_minimo_2.png}
    \caption{Mensaje de error indicando que se debe agregar al menos dos evaluadores.}
    \label{subfig:validacion_minimo_2}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{imagenes/implementaciones/validacion_guia_evaluador.png}
    \caption{Mensaje de error indicando que un integrante de la comisión es guía o coguía.}
    \label{subfig:validacion_guia_evaluador}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \vspace{0.5cm}
    \includegraphics[width=\linewidth]{imagenes/implementaciones/validacion_ajc_ajp.png}
    \caption{Mensaje de error indicando que al menos un integrante debe ser ajc o ajp.}
    \label{subfig:validacion_ajc_ajp}
  \end{subfigure}
  \caption{Mensajes de error por validaciones de comisión examinadora.}
  \label{fig:validaciones_comision}
\end{figure}


\subsection{Cambios por Retroalimentación}\label{subsec:cambios_retroalimentacion}
Luego de realizar la evaluación de la herramienta (capítulo \ref{cap:validacion}),
se recibió una retroalimentación que indicaba que se debían hacer ciertos cambios en el
sistema. El punto de mayor importancia en la retroalimentación era que al presionar el
botón para asignar la comisión examinadora de una memoria demoraba mucho tiempo en aparecer
el modal, pues podía demorar hasta 15 segundos. Esta cantidad de tiempo es inaceptable para
la experiencia del usuario, en especial porque es un botón que se debe presionar por cada memoria.
Por lo tanto, se revisó el código del modal para ver posibles problemas y optimizaciones.

El problema se encontraba en el controlador del modal, que es llamado cada vez que se
presiona el botón para abrir el modal y responde con el HTML del modal. Que se llame
cada vez no es un problema, pero el trabajo que realizaba el controlador en cada llamada
era innecesariamente excesivo, ya que por cada llamada se obtenían todos los evaluadores
habílitados y a cada uno se le generaba un string con sus áreas de conocimiento con sus
respectivas subareas. Este proceso se realizaba para poblar el selector de evaluadores en
el modal. Para optimizar el proceso de poblar el selector de evaluadores, se tomaron dos
medidas: Precalcular el string con las áreas de conocimiento y obtener una única vez los
evaluadores.

Para realizar la primera medida, se agregó el atributo \verb|areas_string| al modelo Evaluador,
que almacena el string con las áreas de conocimiento de un evaluador. Además, se agregó
un método para calcular el string con las áreas de conocimiento de un evaluador y se
añadió una señal que se llama al método cada vez que haya un cambio en las áreas
del evaluador. Esto permite que el string solo se calcule cuando es necesario y no cada
vez que se llama el controlador del modal. En los códigos \ref{lst:senal_evaluador} y
\ref{lst:metodo_generate_areas_string} se muestra el código de la señal y el método
respectivamente.

\begin{lstlisting}[language=Python, caption={Código de la señal que actualiza el string con las áreas de conocimiento de un evaluador}, label={lst:senal_evaluador}, escapechar=|]
@receiver(m2m_changed, sender=Evaluador.areas.through)
def update_areas_string(sender, instance, action, **kwargs):
    """
    Actualiza el campo areas_string de un evaluador cada vez que cambian sus |\'a|reas.
    """
    if action in {"post_add", "post_remove", "post_clear"}:
        instance.generate_areas_string()
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Código del método para generar el string con las áreas de conocimiento de un evaluador}, label={lst:metodo_generate_areas_string}, escapechar=|]
    def generate_areas_string(self):
        """
        Genera un string con las |\'a|reas del evaluador y lo guarda en el atributo areas_string.
        El string tiene el siguiente formato: Padre - Hijo - Hijo - Hijo, Padre, Padre - Hijo
        """
        areas_by_parent = {}
        for area in self.areas.all():
            # Obtenemos el |\'a|rea padre (puede ser None)
            parent = area.padre
            parent_name = parent.nombre if parent else None
            child_name = area.nombre

            if parent_name:
                areas_by_parent.setdefault(parent_name, set()).add(child_name)
            else:
                if child_name not in areas_by_parent:
                    areas_by_parent[child_name] = set()

            # Construimos el string final
        result = []
        for parent, children in sorted(areas_by_parent.items()):
            if children:
                hijos_ordenados = sorted(children)
                result.append(f"{parent} - " + " - ".join(hijos_ordenados))
            else:
                result.append(parent)

        # Unimos todas las areas padre separadas por comas
        # Padre - Hijo - Hijo - Hijo, Padre, Padre - Hijo
        self.areas_string = ", ".join(result)
        self.save()
\end{lstlisting}

Para la segunda medida, se dejó de obtener a los evaluadores en el controlador del modal
y pasaron a obtenerse una vez al cargar la página del módulo de comisiones. Esto no significa
un mayor costo, ya que los evaluadores ya eran obtenidos al cargar la página, dado que el
gráfico de carga de evaluadores ya los obtenía. Estos evaluadores se almacenan en un
arreglo de objeto, almacenando su id, nombre, áreas de conocimiento, memorias guíadas,
comisiones integradas y jerarquía, para que puedan ser utilizados en el modal y el gráfico..

Un segundo punto a mejorar indicado en la retroalimentación fue al guardar una comisión,
se refrescaba la página, lo cual hacía que el usuario tuviera que bajar nuevamente hasta
la memoria que estaba viendo, lo cual es trabajo innecesario. Para resolver este problema,
se evitó refrescar la página y que al guardar una comisión el listado de integrantes se actualice
mediante JavaScript, se actualice el contenido del arreglo que se utiliza para poblar el listado de integrantes
y se actualice el gráfico de carga de integrantes.


\section{Exportación de Comisiones}
Para exportar las comisiones examinadoras, el sistema ofrece dos opciones: descargar
un archivo CSV y enviarlas a través de una petición POST la API del SSM.

\subsection{Archivo CSV}
El piloto desarrollado por el equipo de ingeniería de software II ya contaba con la
funcionalidad de exportar las comisiones examinadoras a un archivo CSV. Sin embargo,
el formato del archivo no seguía el formato requerido por el SSM, como se mencionó en las
secciones \ref{sec:sa:ssm} y \ref{sec:sa:asignacion}. Por lo tanto, se cambiaron las
columnas del archivo para que cumplan con los requisitos del SSM, se cambió el separador
al carácter coma y se agregaron las columnas que faltaban. Por último, se agregó la
condición de que solo las memorias con comisión completa sean exportadas


\subsection{Exportación directa al SSM}
Se implementó una exportación directa al SSM a través de una petición POST al SSM.
Esta implementación consta de dos partes. La primera es hacer que el SSM sea capaz de
recibir una petición desde otro sistema y procesarla. Mientras que la segunda es que el
sistema de titulación envíe una petición POST al SSM con los datos de las comisiones examinadoras.
Esta funcionalidad fue implementada luego de la evaluación por falta de tiempo.

\subsubsection{Adaptación del SSM}\label{subsubsec:adaptacion_ssm}
Para adaptar el SSM a recibir una petición POST desde otro sistema, se creó una view
de Django en el endpoint \texttt{/api/comisiones/} que recibe la petición POST con un
JSON en el cuerpo de la petición. Debido a que en el SSM las memorias se separan por
curso, es decir, por ramo y por sección, se decidió que en el JSON recibido, las
comisiones deben estar separadas por cursos. Además, es necesario que este contenga la
información necesaria para crear los cursos en la base de datos, en caso de que alguno
no exista. Esta corresponde al código del ramo, el número de la sección, el año y el
semestre, siendo ``O'' para el semestre de otoño y ``P'' para el semestre de primavera,
ya que así lo tiene definido el SSM. Por último, por cada comisión se debe tener el tema
de la memoria,nombre y correo del estudiante, del guía y del coguía, además de la lista
de integrantes. El campo coguía puede ser nulo si no hay co-guía. Un ejemplo de JSON
recibido con un solo curso y una sola comisión se puede ver en el código
\ref{lst:ssm_json}.
\newpage
\begin{lstlisting}[label=lst:ssm_json, caption={Ejemplo de JSON recibido con un solo curso y una sola comisión.}]
{
  "cursos": [{
    "codigo": "CC6919",
    "seccion": 1,
    "semestre": "P",
    "anno": 2025,
    "memorias": [{
      "estudiante": {
        "nombre": "Vicente Olivares",
        "correo": "vicente.olivares@ug.uchile.cl"
      },
      "tema": "Tema de ejemplo",
      "guia": {
        "nombre": "Nombre de ejemplo",
        "correo": "guia@example.com"
      },
      "coguia": null,
      "integrantes": [{
        "nombre": "Integrante de ejemplo 1",
        "correo": "integrante1@example.com"
      }, {
        "nombre": "Integrante de ejemplo 2",
        "correo": "integrante2@example.com"
      }]
    }]
  }]
}
\end{lstlisting}

Al recibir el JSON, primero se valida el formato de este. Se verifica que tenga la clave
\texttt{cursos} y que su valor no sea nulo, y se valida que las memorias de cada curso
contengan los campos \texttt{estudiante}, \texttt{tema}, \texttt{guia} y
\texttt{integrantes}. En segundo lugar, se verifica que el contenido no tenga
inconsistencias. Para esto se corrobora que no haya dos comisiones con el mismo
estudiante y que dentro de cada comisión, el guía, coguía e integrantes sean diferentes.
Si cualquiera de estas validaciones falla, se retorna un error 400 BadRequest con un mensaje
indicando qué validación falló.

En tercer lugar, se guardan los datos en la base de datos. Para esto, primero por cada
curso se obtiene la instancia correspondiente del modelo Curso, si no existe se crea.
Luego, por cada comisión se obtiene o crea al estudiante del modelo Estudiante y al guía, coguía
e integrantes del modelo Profesor. Al igual que con los cursos, se registran en la base
de datos si estos no existían previamente. Después, se obtiene o se crea la instancia de
la memoria en el modelo Memoria. Si esta se crea, se agregan al guía, coguía
e integrantes como miembros de la comisión con su respectivo rol a través del Modelo
Miembro. Mientras que si ya existía, primero se eliminan los miembros anteriores y luego
se agregan los miembros que vienen en el JSON. Este comportamiento se implementó así,
para que se puedan corregir los miembros de la comisión a través de la API.
Habiendo terminado lo anterior, se retorna un mensaje de éxito 201 Created.
El código \ref{lst:guardado_comisiones} muestra el código del guardado de las comisiones
sin las validaciones.

\begin{lstlisting}[language=Python, escapechar=|, label={lst:guardado_comisiones}, caption={Guardado de datos en la base de datos.}]
    # Guardado de datos
    for memoria in memorias:
        try:
            estudiante, _ = Estudiante.objects.get_or_create(
                nombre=nombre_normalizado(memoria.get("estudiante").get("nombre")),
                defaults={
                    "correo": memoria.get("estudiante").get("correo"),
                },
            )
            memoria_instance, memoria_created = Memoria.objects.get_or_create(curso=curso, estudiante=estudiante, tema=memoria.get("tema"))

            if not memoria_created:
                Miembro.objects.filter(memoria=memoria_instance).delete()

            if "guia" in memoria and memoria.get("guia") is not None:
                profesor, _ = Profesor.objects.get_or_create(
                    nombre=nombre_normalizado(memoria.get("guia").get("nombre")),
                    defaults={
                        "correo": memoria.get("guia").get("correo"),
                    },
                )
                Miembro.objects.create(memoria=memoria_instance, profesor=profesor, rol=rol_guia)
            if "coguia" in memoria and memoria.get("coguia") is not None:
                profesor, _ = Profesor.objects.get_or_create(
                    nombre=nombre_normalizado(memoria.get("coguia").get("nombre")),
                    defaults={
                        "correo": memoria.get("coguia").get("correo"),
                    },
                )
                Miembro.objects.create(memoria=memoria_instance, profesor=profesor, rol=rol_coguia)
            for integrante in memoria.get("integrantes"):
                profesor, _ = Profesor.objects.get_or_create(
                    nombre=nombre_normalizado(integrante.get("nombre")),
                    defaults={
                        "correo": integrante.get("correo"),
                    },
                )
                Miembro.objects.create(memoria=memoria_instance, profesor=profesor, rol=rol_integrante)

        except ValidationError as e:
            return Response(
                {"error": f"Error al guardar la memoria de '{memoria.get('estudiante').get('nombre')}': {e}"},
                status=status.HTTP_400_BAD_REQUEST,
            )
        except Exception as e:
            return Response(
                {"error": f"Error al guardar la memoria de '{memoria.get('estudiante').get('nombre')}': {e}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

return Response({"success": "Comisiones importadas correctamente."}, status=status.HTTP_201_CREATED)
\end{lstlisting}

Es importante mencionar que tanto en el modelo Estudiante como el modelo Profesor, se
debe buscar por nombre, pues este se define como único. Además, al guardar una instancia
de Profesor o Estudiante, se normalizan sus nombres, es decir, que todas las
palabras del string se transforman para que comiencen con mayúscula y el resto de
caracteres estén en minúscula, como se muestra en el código \ref{lst:estudiante}. Este
comportamiento estaba definido previamente en el SSM. Debido a lo anterior, al realizar
la búsqueda por nombre, se debe buscar con el nombre normalizado, ya que de lo contrario
puede que no se encuentren nombres con apellidos como ``De la Fuente'' o nombres como
``Juan-Bastián'', pues al normalizarlos se convierten en ``De La Fuente'' (la pasa a mayúscula)
y ``Juan-bastián'' (Bastián pasa a minúscula) respectivamente.

\begin{lstlisting}[language=Python, escapechar=|, label={lst:estudiante}, caption={Modelo Estudiante en el SSM.}]
  class Estudiante(models.Model):
    nombre = models.CharField(max_length=300, unique=True)
    correo = models.EmailField(max_length=200, null=True, blank=True)

    def save(self, *args, **kwargs):
      self.nombre = " ".join(word.capitalize() for word in self.nombre.split())
      super().save(*args, **kwargs)
\end{lstlisting}


Además de la implementación del procesamiento del JSON, se restringió el acceso a la
API, para que no cualquier persona que haga un POST pueda enviar datos al SSM. Con este
objetivo, se agregó autenticación con tokens al endpoint de la API y para ello, se agregó
la extensión de Django llamada Django Rest Framework (DRF) al proyecto, que proporciona
herramientas para crear APIs Restful y extiende las posibilidades de autenticación para
endpoints. Entonces, se creó un usuario para el sistema de titulación, de nombre
\verb|sistema_titulacion|, al cual se le generó un token de autenticación. Con este token
el sistema de titulación podrá autenticarse y hacer peticiones POST al endpoint de la
API. Para la autenticación es necesario enviar en el header \texttt{Authorization} de la
petición el token con el prefijo ``Token ''. Cómo se puede ver en el código
\ref{lst:decorators}, para proteger el endpoint como se mencionó anteriormente, se
utilizaron decoradores de DRF sobre la view de Django que define el endpoint. El
decorador \verb|@permission_classes| es para restringir el acceso al endpoint y el
decorador \verb|@authentication_classes| se utiliza para especificar el tipo de
autenticación que se utilizará.

\begin{lstlisting}[language=Python, escapechar=|, label={lst:decorators}, caption={Decoradores utilizados en la API.}]
@api_view(["POST"])
@permission_classes([IsAuthenticated])
@authentication_classes([TokenAuthentication])
def import_comisiones(request):
    data = request.data
    if not data or data.get("cursos") is None:
      return Response({"error": "No se encontraron datos para importar."}, status=status.HTTP_400_BAD_REQUEST)
\end{lstlisting}

Es relevante señalar que el modelo Curso del SSM incluye dentro de sus atributos la fecha
límite para la entrega del informe final de Trabajo de Título \verb|fecha_entrega_informe_final|
y cuando se crea un curso mediante la importación de comisiones por la API, este campo se
inicializa en \verb|None|, dado que dicha información no la maneja el sistema de titulación.
El modelo permite crear cursos sin fecha de entrega y es posible asignarle una fecha a cada
curso en el SSM más tarde a través de la interfaz gráfica. Sin embargo, la aplicación no
estaba diseñada para manejar cursos sin fecha de entrega, ya que varías veces se intentaba
calcular una diferencia entre fechas, causando que el sistema arrojara errores. Entonces,
se adaptó el SSM para que los casos en los que la fecha de entrega sea \verb|None| no cause
errores y en la interfaz aparezca \verb|SIN DEFINIR| en rojo y negrita que sea notorio que
se requiere asignar una fecha de entrega, como se puede ver en la figura
\ref{subfig:listado_memorias_ssm}. Además, se aprovechó el sistema de notificaciones del SSM
para enviar una notificación al usuario por cada curso sin fecha de entrega definida,
como se puede ver en la figura \ref{subfig:notificacion_ssm}.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0.9\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagenes/implementaciones/ssm/listado_memorias_ssm.png}
    \caption{Comisiones de un curso sin fecha de entrega definida}
    \label{subfig:listado_memorias_ssm}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagenes/implementaciones/ssm/notificacion_ssm.png}
    \caption{Notificación de fecha de entrega}
    \label{subfig:notificacion_ssm}
  \end{subfigure}
  \caption{Cambios en la interfaz del SSM para manejar cursos sin fecha de entrega}
\end{figure}


\subsubsection{Exportación de Comisiones desde el Sistema de Titulación}
La exportación de comisiones desde el Sistema de Titulación ejecuta al presionar el botón
\verb|Exportar| en la vista del listado de comisiones. Este botón realiza una llamada al
endpoint \verb|/comisiones/exportar/<periodo_id>|, donde \verb|<periodo_id>| es el id del periodo
académico que se desea exportar. El controlador de este endpoint se puede apreciar en el código
\ref{lst:export_comisiones_view}, y se encarga de llamar al comando \verb|export_comisiones_ssm|,
que tiene la tarea de realizar la exportación de comisiones, y luego redirigir al usuario al
listado de comisiones. Si el comando arroja un error, se envía un mensaje de error al usuario.
Por otro lado, si todo sale bien, se envía un mensaje de éxito al usuario. Cabe destacar que es
necesario redirigir al usuario para que el mensaje de éxito o error se muestre en la interfaz
gráfica, puesto que así está diseñado el sistema de mensajes en el sistema de titulación.

\begin{lstlisting}[language=Python, escapechar=|, label={lst:export_comisiones_view}, caption={Código del controlador que llama al comando de exportación de comisiones.}]
def get(self, request, *args, **kwargs):
  periodo = self.get_periodo()

  try:
    resultado_comando = call_command("export_comisiones_ssm", "--periodo_id", str(periodo.id))
    if resultado_comando == settings.FALLO_EN_COMANDO:
      self.msg_error("Se ha producido un error al exportar la lista de comisiones.")
      return HttpResponseRedirect(reverse_lazy("comisiones:comisiones_list", kwargs={"periodo_id": periodo.id}))
    else:
      self.msg_success("Listado de comisiones exportado correctamente.")
      return HttpResponseRedirect(reverse_lazy("comisiones:comisiones_list", kwargs={"periodo_id": periodo.id}))
  except CommandError as e:
    self.msg_error(str(e))
    return HttpResponseRedirect(reverse_lazy("comisiones:comisiones_list", kwargs={"periodo_id": periodo.id}))
  except Exception:
    self.msg_error("Se ha producido un error al exportar la lista de comisiones.")
    return HttpResponseRedirect(reverse_lazy("comisiones:comisiones_list", kwargs={"periodo_id": periodo.id}))
\end{lstlisting}

El comando \verb|export_comisiones_ssm|, que se puede apreciar en el código
\ref{lst:export_comisiones}, recibe como parámetro el periodo académico de las comisiones
que se debe exportar y en caso de no recibir ninguno, se toma el periodo académico
activo. Luego, se envían las memorias y comisiones de los estudiantes separadas por curso
en un JSON a la API del SSM. El formato del JSON es el indicado en la sección
\ref{subsubsec:adaptacion_ssm}. Solo se envían las comisiones que tengan al menos dos
evaluadores asignados. En caso de que la respuesta de la API no sea 200 ok o 201 created,
se registra el mensaje de error en el log y se arroja un \verb|CommandError| con el mensaje
de error. Por último, para incorporar las credenciales de la API del SSM, se agregaron
las variables de entorno \verb|SSM_URL| y \verb|SSM_TOKEN| que corresponden a la URL y el
token de la API del SSM, respectivamente.

\newpage
\begin{lstlisting}[language=Python, escapechar=|, label={lst:export_comisiones}, caption={Comando de exportación de comisiones.}]
def handle(self, *args, **options):
  periodo_id = options.get("periodo_id")
  if periodo_id is None:
    periodo = Periodo.objects.filter(is_activo=True).first()
  else:
    try:
      periodo = Periodo.objects.get(id=periodo_id)
    except Periodo.DoesNotExist:
      self.stdout.write(self.style.ERROR("Periodo no encontrado."))
      return settings.FALLO_EN_COMANDO

  cursos = Curso.objects.select_related("periodo").filter(periodo=periodo)
  memorias = MemoriaEnF.objects.select_related(
    "estudiante__persona",
    "tema__guia__persona",
    "tema__coguia__persona"
  ).prefetch_related(
    "comision__evaluadores__persona"
  ).filter(periodo=periodo)

  comisiones_por_curso = {
    "cursos": [
      {
        "codigo": curso.codigo,
        "seccion": curso.seccion,
        "semestre": "O" if curso.periodo.periodo == 1 else "P",
        "anno": curso.periodo.ano,
        "memorias": [
          memoria.to_ssm_dict() for memoria in memorias.filter(curso=curso) if memoria.comision.evaluadores.count() >= 2
        ]
      } for curso in cursos
    ]

  }

  response = requests.post(
    settings.SSM_URL + "/api/comisiones/",
    json=comisiones_por_curso,
    headers={"Authorization": f"Token {settings.SSM_TOKEN}"},
  )

  if response.status_code not in (requests.codes.ok, requests.codes.created):
    self.stdout.write(self.style.ERROR(f"Error al exportar comisiones: {response.text}"))
    raise CommandError(response.json()["error"])

  # Establece la |comisi\'on| de un estudiante como publicada y se podr\'a ver en la ficha del estudiante
  for memoria in memorias:
    memoria.comision.publicada = True
    memoria.comision.save()

  self.stdout.write(self.style.SUCCESS("Comisiones exportadas correctamente"))

  return 0
\end{lstlisting}
